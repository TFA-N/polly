root        -> COMMAND (expr (WS expr)*)?            // AST root with a WS separated list of expressions
expr        -> assign (';' assign)*                  // implicit list
assign      -> relation '->' ID                      // assignment of relation to identifier X
relation    -> conjunction (REL_OP conjunction)*     // relation (<,>,<=,>=,==)
conjunction -> disjunction (CONJ_OP disjunction)*    // conjunction (||)
disjunction -> secTerm (DISJ_OP secTerm)*            // disjungtion (&&)
secTerm     -> term (SECTERM_OP term)*               // plus minus
term        -> factor (TERM_OP factor)*              // multiplication and co
factor      -> postfix FACTOR_OP factor)?            // right-associative (power operator)
postfix     -> dotdot (POSTFIX_OP dotdot)+           // postfix operator
dotdot      -> unary ('..' unary ('$' unary)?)?      // range operator with optional step size
unary       -> UNARY_OP unary                        // right-associative unary operator
             | access
access      -> literal ('.' varOrCall)?              // namespace access. literal must be a single identifier (represented by a VarAccess)
literal     -> varOrCall
             | '(' expr ')'                          // braced expression
             | '\(' parameters ')'                   // lambda function literal
             | '{' exprList '}'                      // concrete list of expressions
             | TRUE | FALSE                          // boolean literal
             | CHANNEL                               // channel literal
             | USER                                  // user literal
             | STRING                                // string literal
             | NUMBER                                // number literal
             | DATETIME                              // date literal
             | TIMESPAN                              // timespan literal
             | COMMAND                               // command literal

varOrCall   -> ID                                    // var access
             | ID '(' exprList ')'                   // call   
         
exprList    -> (expr (',' expr)*)?
parameters  -> parameter (',' parameter)*
parameter   -> ID ID                                 // typename, parameter name
             | ID<ID> ID                             // type name, subtype name, parameter name
             | '\(' ID (',' ID)+ ')' ID              // return type name, parameter type names, parameter name
            
            
            
(10+5->x)+5